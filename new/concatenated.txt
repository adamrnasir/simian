# ./simulation.py
import numpy as np
from numba import jit, int32, boolean
from collections import defaultdict

# Material constants
AIR = 0
SAND = 1


@jit(nopython=True)
def update_grid(grid, active_cells, width, height):
    new_grid = grid.copy()
    new_active_cells = set()

    for y, x in active_cells:
        material = grid[y, x]

        if material == SAND:
            moved = False
            # Check directly below
            if y < height - 1 and new_grid[y + 1, x] == AIR:
                new_grid[y + 1, x] = SAND
                new_grid[y, x] = AIR
                moved = True
                new_active_cells.add((y + 1, x))
            # Check bottom-left
            elif y < height - 1 and x > 0 and new_grid[y + 1, x - 1] == AIR:
                new_grid[y + 1, x - 1] = SAND
                new_grid[y, x] = AIR
                moved = True
                new_active_cells.add((y + 1, x - 1))
            # Check bottom-right
            elif y < height - 1 and x < width - 1 and new_grid[y + 1, x + 1] == AIR:
                new_grid[y + 1, x + 1] = SAND
                new_grid[y, x] = AIR
                moved = True
                new_active_cells.add((y + 1, x + 1))

            if moved:
                # Add neighboring cells to active cells
                for dy in range(-1, 2):
                    for dx in range(-1, 2):
                        ny, nx = y + dy, x + dx
                        if 0 <= ny < height and 0 <= nx < width:
                            new_active_cells.add((ny, nx))
            else:
                new_active_cells.add((y, x))

    return new_grid, new_active_cells


class Simulation:
    AIR = AIR
    SAND = SAND

    def __init__(self, width, height):
        self.width = width
        self.height = height
        self.grid = np.zeros((height, width), dtype=np.int8)
        self.active_cells = set()

    def add_material(self, x, y, material, radius):
        y_range = slice(max(0, y - radius), min(self.height, y + radius + 1))
        x_range = slice(max(0, x - radius), min(self.width, x + radius + 1))

        Y, X = np.ogrid[y_range, x_range]
        dist_from_center = np.sqrt((X - x) ** 2 + (Y - y) ** 2)

        mask = dist_from_center <= radius
        self.grid[y_range, x_range][mask] = material

        # Add affected cells and their neighbors to active cells
        for dy in range(y_range.start, y_range.stop):
            for dx in range(x_range.start, x_range.stop):
                if mask[dy - y_range.start, dx - x_range.start]:
                    for ny in range(max(0, dy - 1), min(self.height, dy + 2)):
                        for nx in range(max(0, dx - 1), min(self.width, dx + 2)):
                            self.active_cells.add((ny, nx))

    def update(self):
        self.grid, self.active_cells = update_grid(
            self.grid, list(self.active_cells), self.width, self.height
        )

# ./render.py
import pygame
import numpy as np
import asyncio


class Renderer:
    def __init__(self, window, simulation):
        self.window = window
        self.simulation = simulation
        self.pixel_size = 1
        self.colors = {
            simulation.AIR: np.array([255, 255, 255], dtype=np.uint8),
            simulation.SAND: np.array([194, 178, 128], dtype=np.uint8),
        }
        self.surface = pygame.Surface((simulation.width, simulation.height))
        self.prev_grid = np.full_like(
            simulation.grid, -1
        )  # Initialize with invalid values

    async def render(self):
        # Find changed cells
        changed = self.simulation.grid != self.prev_grid
        if not np.any(changed):
            return  # No changes, skip rendering

        # Update only the changed cells
        mask = np.zeros(
            (self.simulation.height, self.simulation.width, 3), dtype=np.uint8
        )
        for material, color in self.colors.items():
            mask[self.simulation.grid == material] = color

        # Update the surface only where changes occurred
        changed_indices = np.where(changed)
        await self._update_changed_pixels(changed_indices, mask)

        # Update the previous grid
        self.prev_grid = self.simulation.grid.copy()

        # Scale and blit to the window
        pygame.transform.scale(self.surface, self.window.get_size(), self.window)

    async def _update_changed_pixels(self, changed_indices, mask):
        tasks = []
        for y, x in zip(*changed_indices):
            tasks.append(self._update_pixel(x, y, mask[y, x]))
        await asyncio.gather(*tasks)

    async def _update_pixel(self, x, y, color):
        pygame.Surface.set_at(self.surface, (x, y), color)

# ./main.py
import pygame
import numpy as np
from simulation import Simulation
from render import Renderer
import cProfile
import pstats
import asyncio


async def main():
    pygame.init()
    width, height = 800, 600  # Increased screen size
    window = pygame.display.set_mode((width, height))
    pygame.display.set_caption("Large-Scale Quantized Particle Physics Simulation")

    simulation = Simulation(width, height)  # Grid size matches screen size
    renderer = Renderer(window, simulation)

    clock = pygame.time.Clock()
    running = True

    # Create a Profile object
    pr = cProfile.Profile()

    while running:
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
                # Save profiling results to a file
                with open("profiling_results.txt", "w") as file:
                    ps = pstats.Stats(pr, stream=file).sort_stats("cumulative")
                    ps.print_stats()
            elif event.type == pygame.MOUSEBUTTONDOWN:
                x, y = pygame.mouse.get_pos()
                simulation.add_material(x, y, simulation.SAND, 10)

        # Start profiling
        pr.enable()

        simulation.update()
        await renderer.render()

        # Stop profiling
        pr.disable()

        pygame.display.flip()
        clock.tick(60)
        print(f"FPS: {clock.get_fps():.2f}")

    pygame.quit()


if __name__ == "__main__":
    asyncio.run(main())

