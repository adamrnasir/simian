# ./simulation.py
import pygame
import pymunk
import pymunk.pygame_util
import time
from typing import List, Dict
from particle import Particle
from materials import (
    Ball,
    Water,
    Fire,
    Steam,
    Gravel,
    Sand,
    Lava,
    Paint,
    Wood,
    Glass,
    Acid,
)  # Add Paint import
from ui import UI
import random


class Simulation:
    def __init__(self, window, width, height):
        self.window = window
        self.width = width
        self.height = height
        self.space = pymunk.Space()
        self.space.gravity = (0, 980)
        self.draw_options = pymunk.pygame_util.DrawOptions(window)
        self.particles: Dict[str, List[Particle]] = {
            "Ball": [],
            "Water": [],
            "Fire": [],
            "Steam": [],
            "Gravel": [],  # Add Gravel to particles dictionary
            "Sand": [],  # Add Sand to particles dictionary
            "Lava": [],  # Add Lava to particles dictionary
            "Glass": [],  # Add Glass to particles dictionary
            "Wood": [],  # Add Wood to particles dictionary
            "Acid": [],  # Add Acid to particles dictionary
        }
        self.material_classes = {
            "Ball": Ball,
            "Water": Water,
            "Fire": Fire,
            "Steam": Steam,
            "Gravel": Gravel,  # Add Gravel to material_classes dictionary
            "Sand": Sand,  # Add Sand to material_classes dictionary
            "Lava": Lava,  # Add Lava to material_classes dictionary
            "Glass": Glass,  # Add Glass to material_classes dictionary
            "Wood": Wood,  # Add Wood to material_classes dictionary
            "Acid": Acid,  # Add Acid to material_classes dictionary
        }
        self.ui = UI(window, width, height, self.space)
        self.create_ui()
        self.create_walls()
        self.setup_collision_handler()
        self.stream_timer = 0
        self.last_update_time = time.time()
        self.grid_size = 4  # Change grid size to match the smallest particle size
        self.fire_spread_timer = 0
        self.fire_spread_interval = 0.1  # Spread fire every 0.1 seconds
        self.max_paint_distance = 10  # Maximum distance between paint particles

    def create_walls(self):
        wall_thickness = 20
        body = pymunk.Body(body_type=pymunk.Body.STATIC)
        walls = [
            pymunk.Segment(body, (0, 0), (self.width, 0), wall_thickness),
            pymunk.Segment(
                body, (self.width, 0), (self.width, self.height), wall_thickness
            ),
            pymunk.Segment(
                body, (self.width, self.height), (0, self.height), wall_thickness
            ),
            pymunk.Segment(body, (0, self.height), (0, 0), wall_thickness),
        ]
        for wall in walls:
            wall.elasticity = 0.8
            wall.friction = 0.1
            wall.collision_type = 1
        self.space.add(body, *walls)

    def create_ui(self):
        materials = {
            "Ball": Ball.COLOR,
            "Water": Water.COLOR,
            "Fire": Fire.COLOR,
            "Steam": Steam.COLOR,
            "Gravel": Gravel.COLOR,
            "Sand": Sand.COLOR,
            "Lava": Lava.COLOR,
            "Glass": Glass.COLOR,
            "Wood": Wood.COLOR,
            "Acid": Acid.COLOR,
        }
        self.ui.create_buttons(materials)

    def setup_collision_handler(self):
        for i in range(2, 8):  # Update range to include Paint's collision type (7)
            for j in range(2, 8):
                handler = self.space.add_collision_handler(i, j)
                handler.begin = self.handle_collision

    def handle_collision(self, arbiter, space, data):
        shape_a, shape_b = arbiter.shapes
        particle_a = shape_a.body.particle
        particle_b = shape_b.body.particle

        # If either particle is Paint, don't process the collision further
        if isinstance(particle_a.material, Paint) or isinstance(
            particle_b.material, Paint
        ):
            return True

        new_particles = []
        particles_to_remove = []

        new_particles.extend(
            particle_a.material.handle_collision(space, particle_a, particle_b)
        )
        new_particles.extend(
            particle_b.material.handle_collision(space, particle_b, particle_a)
        )

        # Check if particles should be removed
        if particle_a.body not in space.bodies:
            particles_to_remove.append(particle_a)
        if particle_b.body not in space.bodies:
            particles_to_remove.append(particle_b)

        # Remove particles from the simulation's particle lists
        for particle in particles_to_remove:
            material_name = particle.material.__name__
            if material_name in self.particles:
                self.particles[material_name] = [
                    p for p in self.particles[material_name] if p != particle
                ]

        # Add new particles to the simulation
        for new_particle in new_particles:
            material_name = new_particle.material.__name__
            if material_name in self.particles:
                self.particles[material_name].append(new_particle)
            else:
                print(f"Warning: Unknown material {material_name}")

        return True

    def run(self):
        running = True
        while running:
            events = pygame.event.get()
            for event in events:
                if event.type == pygame.QUIT:
                    running = False

            self.ui.handle_events(events)
            self.update()
            self.draw()
            pygame.display.flip()
            self.space.step(1 / 60.0)

    def update(self):
        current_time = time.time()
        dt = current_time - self.last_update_time
        self.last_update_time = current_time

        self.remove_out_of_bounds_particles()
        self.remove_flagged_particles()
        self.update_particles(dt)
        self.limit_particles()

        self.fire_spread_timer += dt
        if self.fire_spread_timer >= self.fire_spread_interval:
            self.spread_fire()
            self.fire_spread_timer = 0

        if self.ui.stream_active:
            x, y = self.ui.get_mouse_position()
            self.create_particles(x, y)

    def remove_out_of_bounds_particles(self):
        for material, particle_list in self.particles.items():
            self.particles[material] = [
                p for p in particle_list if self.is_in_bounds(p)
            ]

    def is_in_bounds(self, particle):
        x, y = particle.body.position
        return 0 <= x <= self.width and 0 <= y <= self.height

    def update_particles(self, dt):
        gravity = self.space.gravity
        for material_name, particle_list in self.particles.items():
            material_class = self.material_classes[material_name]
            updated_particles = []
            for particle in particle_list:
                if material_class.update_particle(particle, dt, gravity):
                    updated_particles.append(particle)
                else:
                    # Remove the particle from the space
                    self.space.remove(particle.body, particle.shape)
            self.particles[material_name] = updated_particles

    def limit_particles(self):
        total_particles = sum(len(particles) for particles in self.particles.values())
        if total_particles > 10000:
            remove_count = total_particles - 10000
            for material, particle_list in self.particles.items():
                if remove_count <= 0:
                    break
                if len(particle_list) > remove_count:
                    for particle in particle_list[:remove_count]:
                        self.space.remove(particle.body, particle.shape)
                    self.particles[material] = particle_list[remove_count:]
                    remove_count = 0
                else:
                    remove_count -= len(particle_list)
                    for particle in particle_list:
                        self.space.remove(particle.body, particle.shape)
                    self.particles[material] = []

    def draw(self):
        self.window.fill((0, 0, 0))
        for particle_list in self.particles.values():
            for particle in particle_list:
                particle.draw(self.window)
        total_particles = sum(len(particles) for particles in self.particles.values())
        self.ui.draw(total_particles)

    def remove_flagged_particles(self):
        for material, particle_list in self.particles.items():
            particles_to_remove = [p for p in particle_list if p.to_remove]
            for particle in particles_to_remove:
                self.space.remove(particle.body, particle.shape)
                particle_list.remove(particle)

    def spread_fire(self):
        new_fire_particles = []
        for fire_particle in self.particles["Fire"]:
            if random.random() < 0.1:  # 10% chance to spread fire
                nearby_particles = self.find_nearby_particles(fire_particle, 20)
                for nearby_particle in nearby_particles:
                    if isinstance(nearby_particle.material, Wood):
                        new_fire = Fire.create_particle(
                            self.space,
                            nearby_particle.body.position.x,
                            nearby_particle.body.position.y,
                        )
                        new_fire_particles.append(new_fire)
                        nearby_particle.to_remove = True

        self.particles["Fire"].extend(new_fire_particles)

    def find_nearby_particles(self, particle, radius):
        nearby = []
        for material, particle_list in self.particles.items():
            for other in particle_list:
                if other != particle:
                    distance = particle.body.position.get_distance(other.body.position)
                    if distance <= radius:
                        nearby.append(other)
        return nearby

    def create_particles(self, x, y):
        material_class = self.material_classes[self.ui.selected_material]
        if issubclass(material_class, Paint):
            self.create_paint_stroke(x, y, material_class)
        else:
            # Quantize the initial position
            qx, qy = self.quantize_position(x, y)
            new_particles = material_class.create_particles(self.space, qx, qy)

            # Quantize the position of each new particle
            for particle in new_particles:
                if particle is not None:
                    px, py = self.quantize_position(
                        particle.body.position.x, particle.body.position.y
                    )
                    particle.body.position = pymunk.Vec2d(px, py)

            self.particles[self.ui.selected_material].extend(
                [p for p in new_particles if p is not None]
            )

    def create_paint_stroke(self, end_x, end_y, material_class):
        if self.ui.last_paint_position is None:
            self.ui.last_paint_position = (float(end_x), float(end_y))
            self.create_paint_particles(end_x, end_y, end_x, end_y, material_class)
        else:
            start_x, start_y = self.ui.last_paint_position
            distance = ((end_x - start_x) ** 2 + (end_y - start_y) ** 2) ** 0.5

            # Increase the number of particles created along the stroke
            num_particles = max(
                int(distance / 2), 1
            )  # Create a particle every 2 pixels

            for i in range(num_particles):
                t = i / num_particles
                x = start_x + t * (end_x - start_x)
                y = start_y + t * (end_y - start_y)
                self.create_paint_particles(x, y, x, y, material_class)

        self.ui.last_paint_position = (float(end_x), float(end_y))

    def create_paint_particles(
        self, start_x, start_y, end_x, end_y, material_class, num_particles=1
    ):
        for i in range(num_particles):
            t = i / num_particles
            x = start_x + t * (end_x - start_x)
            y = start_y + t * (end_y - start_y)
            qx, qy = self.quantize_position(x, y)

            # Add some randomness to create a more natural-looking stroke
            qx += random.uniform(-self.grid_size / 2, self.grid_size / 2)
            qy += random.uniform(-self.grid_size / 2, self.grid_size / 2)

            new_particles = material_class.create_particles(self.space, qx, qy, count=1)
            self.particles[self.ui.selected_material].extend(new_particles)

    def quantize_position(self, x, y):
        # Quantize the position to the nearest grid point
        return (
            round(x / self.grid_size) * self.grid_size,
            round(y / self.grid_size) * self.grid_size,
        )

# ./ui.py
import pygame
from typing import List, Tuple, Optional


class Button:
    def __init__(self, x, y, width, height, text, color):
        self.rect = pygame.Rect(x, y, width, height)
        self.text = text
        self.color = color

    def draw(self, window):
        pygame.draw.rect(window, self.color, self.rect)
        font = pygame.font.Font(None, 24)
        text_surface = font.render(self.text, True, (255, 255, 255))
        text_rect = text_surface.get_rect(center=self.rect.center)
        window.blit(text_surface, text_rect)


class UI:
    def __init__(self, window, width, height, space):
        self.window = window
        self.width = width
        self.height = height
        self.buttons: List[Button] = []
        self.selected_material = "Ball"
        self.stream_active = False
        self.last_paint_position: Optional[Tuple[float, float]] = None
        self.space = space

    def create_buttons(self, materials):
        y_offset = 20
        for material, color in materials.items():
            self.buttons.append(Button(20, y_offset, 100, 40, material, color))
            y_offset += 50

    def handle_events(self, events: List[pygame.event.Event]) -> None:
        for event in events:
            if event.type == pygame.MOUSEBUTTONDOWN:
                self.handle_mouse_down(event)
            elif event.type == pygame.MOUSEBUTTONUP:
                self.handle_mouse_up(event)

    def handle_mouse_down(self, event: pygame.event.Event) -> None:
        if event.button == 1:  # Left mouse button
            x, y = event.pos
            for button in self.buttons:
                if button.rect.collidepoint(x, y):
                    self.selected_material = button.text
                    return

            self.stream_active = True
            self.last_paint_position = None

    def handle_mouse_up(self, event: pygame.event.Event) -> None:
        if event.button == 1:  # Left mouse button
            self.stream_active = False
            self.last_paint_position = None

    def draw(self, total_particles: int) -> None:
        for button in self.buttons:
            button.draw(self.window)
        self.draw_selected_material()
        self.draw_particle_count(total_particles)

    def draw_selected_material(self) -> None:
        for button in self.buttons:
            if button.text == self.selected_material:
                pygame.draw.rect(self.window, (255, 255, 0), button.rect, 3)

    def draw_particle_count(self, total_particles: int) -> None:
        font = pygame.font.Font(None, 36)
        text = font.render(f"Particles: {total_particles}", True, (0, 0, 0))
        self.window.blit(text, (256, 10))

    def get_mouse_position(self) -> tuple[int, int]:
        return pygame.mouse.get_pos()

# ./materials.py
import random
import time
from abc import ABC, abstractmethod
from particle import Particle
from pymunk import Vec2d, Space  # Add this import
from typing import Tuple, List
import pymunk


class Material(ABC):
    COLOR = (0, 0, 0)
    MASS = 1.0
    SIZE = 10  # Change RADIUS to SIZE
    ELASTICITY = 0.1
    FRICTION = 0.5
    COLLISION_TYPE = 0
    SPREAD = 5
    VELOCITY_SPREAD = 10

    @classmethod
    @abstractmethod
    def create_particle(cls, space, x, y):
        particle = Particle(
            space,
            x,
            y,
            cls.MASS,
            cls.SIZE,  # Change RADIUS to SIZE
            cls.COLOR,
            collision_type=cls.COLLISION_TYPE,
            elasticity=cls.ELASTICITY,
            friction=cls.FRICTION,
            material=cls,
        )
        return particle

    @classmethod
    def create_particles(cls, space, x, y, count=10):
        particles = []
        for _ in range(count):
            px = x + random.randint(-cls.SPREAD, cls.SPREAD) // 2 * 2
            py = y + random.randint(-cls.SPREAD, cls.SPREAD) // 2 * 2
            particle = cls.create_particle(space, px, py)
            if particle is not None:
                particle.body.velocity = (
                    random.randint(-cls.VELOCITY_SPREAD, cls.VELOCITY_SPREAD) // 2 * 2,
                    random.randint(-cls.VELOCITY_SPREAD, cls.VELOCITY_SPREAD) // 2 * 2,
                )
                particles.append(particle)
        return particles

    @classmethod
    @abstractmethod
    def update_particle(cls, particle, dt, gravity: Tuple[float, float]):
        pass

    @classmethod
    @abstractmethod
    def handle_collision(
        cls, space: Space, particle: Particle, other_particle: Particle
    ) -> List[Particle]:
        pass


class Fluid(Material):
    @classmethod
    def create_particles(cls, space, x, y):
        particles = []
        for _ in range(10):
            px = x + random.uniform(-5, 5)
            py = y + random.uniform(-5, 5)
            particle = cls.create_particle(space, px, py)
            if particle is not None:  # Add this check
                particle.body.velocity = (
                    random.uniform(-50, 50),
                    random.uniform(-50, 50),
                )
                particles.append(particle)
        return particles


class Ball(Material):
    COLOR = (128, 128, 128)
    MASS = 200
    SIZE = 20  # Change RADIUS to SIZE and double the value
    COLLISION_TYPE = 4
    SPREAD = 0
    VELOCITY_SPREAD = 0

    @classmethod
    def create_particle(cls, space, x, y):
        particle = super().create_particle(space, x, y)
        # Add any Ball-specific properties here if needed
        return particle

    @classmethod
    def create_particles(cls, space, x, y):
        return super().create_particles(space, x, y, count=1)

    @classmethod
    def update_particle(cls, particle, dt, gravity):
        return True

    @classmethod
    def handle_collision(
        cls, space: Space, particle: Particle, other_particle: Particle
    ) -> List[Particle]:
        return []  # Ball doesn't react to collisions


class Water(Fluid):
    COLOR = (0, 0, 255)
    COLLISION_TYPE = 2
    SIZE = 4  # Change RADIUS to SIZE
    ELASTICITY = 0.98
    FRICTION = 0.0

    @classmethod
    def create_particle(cls, space, x, y):
        return super().create_particle(space, x, y)

    @classmethod
    def update_particle(cls, particle, dt, gravity):
        return True

    @classmethod
    def handle_collision(
        cls, space: Space, particle: Particle, other_particle: Particle
    ) -> List[Particle]:
        if other_particle.material == Fire or other_particle.material == Lava:
            particle.to_remove = True
            return [
                Steam.create_particle(
                    space, particle.body.position.x, particle.body.position.y
                )
            ]

        return []


class Fire(Fluid):
    COLOR = (255, 69, 0)
    COLLISION_TYPE = 3
    MASS = 0.5
    RADIUS = 3
    UPWARD_FORCE = 1100

    @classmethod
    def create_particle(cls, space, x, y):
        particle = super().create_particle(space, x, y)
        particle.lifetime = random.uniform(1, 2)
        particle.body.velocity = Vec2d(
            random.uniform(-50, 50), random.uniform(-100, -50)
        )
        particle.body.velocity_func = cls.update_velocity
        return particle

    @staticmethod
    def update_velocity(body, gravity, damping, dt):
        # Calculate the net force (upward force - gravity)
        net_force = Vec2d(0, -Fire.UPWARD_FORCE) + gravity

        # Apply the net force to the particle
        body.velocity += net_force * dt

        # Add some random horizontal movement
        body.velocity += Vec2d(random.uniform(-10, 10), 0) * dt

    @classmethod
    def update_particle(cls, particle, dt, gravity):
        age = time.time() - particle.creation_time
        if age > particle.lifetime:
            return False  # This signals that the particle should be removed

        # Update color to fade to red
        particle.color = (255, int(255 * (1 - age / particle.lifetime)), 0)
        return True  # This signals that the particle should be kept

    @classmethod
    def handle_collision(
        cls, space: Space, particle: Particle, other_particle: Particle
    ) -> List[Particle]:
        if other_particle.material == Water:
            particle.to_remove = True
        return []


class Steam(Fluid):
    COLOR = (200, 200, 200, 200)
    MASS = 0.1
    RADIUS = 4
    COLLISION_TYPE = 4
    VELOCITY_SPREAD = 100

    @classmethod
    def create_particle(cls, space, x, y):
        particle = super().create_particle(space, x, y)
        particle.lifetime = random.uniform(1, 3)
        particle.body.velocity_func = cls.update_velocity
        return particle

    @staticmethod
    def update_velocity(body, gravity, damping, dt):
        # Add jittery motion to steam
        jitter = Vec2d(body.velocity.x + random.uniform(-2, 2), -20)
        body.velocity = jitter - gravity * dt  # Counteract gravity

    @classmethod
    def update_particle(cls, particle, dt, gravity):
        age = time.time() - particle.creation_time
        if age > particle.lifetime:
            return False

        # Update color to fade to transparent
        alpha = int(200 * (1 - age / particle.lifetime))
        particle.color = (*particle.color[:3], alpha)
        return True

    @classmethod
    def handle_collision(
        cls, space: Space, particle: Particle, other_particle: Particle
    ) -> List[Particle]:
        return []  # Steam doesn't react to collisions


class Gravel(Material):
    COLOR = (89, 89, 89)  # Brown color
    MASS = 5.0
    RADIUS = 4
    ELASTICITY = 0.2  # Low elasticity
    FRICTION = 0.8  # High friction
    COLLISION_TYPE = 5

    @classmethod
    def create_particle(cls, space, x, y):
        return super().create_particle(space, x, y)

    @classmethod
    def update_particle(cls, particle, dt, gravity):
        # Gravel is fully affected by gravity
        particle.body.velocity += Vec2d(*gravity) * dt
        return True

    @classmethod
    def handle_collision(
        cls, space: Space, particle: Particle, other_particle: Particle
    ) -> List[Particle]:
        if other_particle.material == Fire:
            particle.to_remove = True
            return [
                Lava.create_particle(
                    space, particle.body.position.x, particle.body.position.y
                )
            ]
        elif other_particle.material == Acid:
            particle.to_remove = True
            return []
        return []


class Sand(Material):
    COLOR = (216, 216, 191)
    MASS = 2.0
    RADIUS = 3
    COLLISION_TYPE = 6
    FRICTION = 1.0
    ELASTICITY = 0.1

    @classmethod
    def create_particle(cls, space, x, y):
        particle = super().create_particle(space, x, y)
        return particle

    @classmethod
    def update_particle(cls, particle, dt, gravity):
        # Sand is fully affected by gravity
        particle.body.velocity += Vec2d(*gravity) * dt
        return True

    @classmethod
    def handle_collision(
        cls, space: Space, particle: Particle, other_particle: Particle
    ) -> List[Particle]:
        if other_particle.material == Fire or other_particle.material == Lava:
            particle.to_remove = True
            return [
                Glass.create_particle(
                    space, particle.body.position.x, particle.body.position.y
                )
            ]
        elif other_particle.material == Acid:
            particle.to_remove = True
            return []
        return []


class Lava(Fluid):
    COLOR = (255, 0, 0)
    MASS = 1.0
    RADIUS = 3
    COLLISION_TYPE = 3
    FRICTION = 0.5
    ELASTICITY = 0.1

    @classmethod
    def create_particle(cls, space, x, y):
        return super().create_particle(space, x, y)

    @classmethod
    def update_particle(cls, particle, dt, gravity):
        return True

    @classmethod
    def handle_collision(
        cls, space: Space, particle: Particle, other_particle: Particle
    ) -> List[Particle]:
        if other_particle.material == Water:
            particle.to_remove = True
            return [
                Gravel.create_particle(
                    space, particle.body.position.x, particle.body.position.y
                )
            ]
        return []


class Paint(Material):
    COLOR = (0, 255, 0)  # Default color (green), but we'll make it customizable
    MASS = 100
    SIZE = 6
    COLLISION_TYPE = 7
    FRICTION = 1.0  # Increase friction
    ELASTICITY = 0.0  # Reduce elasticity to zero
    SPREAD = 0
    VELOCITY_SPREAD = 0

    @classmethod
    def create_particle(cls, space, x, y, color=None):
        particle = super().create_particle(space, x, y)
        particle.body.body_type = pymunk.Body.STATIC  # Make the body static
        return particle

    @classmethod
    def create_particles(cls, space, x, y, count=1, color=None):
        particles = []
        for _ in range(count):
            particle = cls.create_particle(space, x, y, color)
            particles.append(particle)
        return particles

    @classmethod
    def update_particle(cls, particle, dt, gravity):
        # Paint particles don't need to be updated
        return True

    @classmethod
    def handle_collision(
        cls, space: Space, particle: Particle, other_particle: Particle
    ) -> List[Particle]:
        # Paint particles don't react to collisions
        return []


class Wood(Paint):
    COLOR = (139, 69, 19)
    MASS = 100
    SIZE = 6
    COLLISION_TYPE = 2
    FRICTION = 1.0
    ELASTICITY = 0.1
    SPREAD = 0
    VELOCITY_SPREAD = 0

    @classmethod
    def create_particle(cls, space, x, y, color=None):
        return super().create_particle(space, x, y)

    @classmethod
    def create_particles(cls, space, x, y, count=1, color=None):
        return super().create_particles(space, x, y, count, color)

    @classmethod
    def update_particle(cls, particle, dt, gravity):
        return super().update_particle(particle, dt, gravity)

    @classmethod
    def handle_collision(
        cls, space: Space, particle: Particle, other_particle: Particle
    ) -> List[Particle]:
        if (
            other_particle.material == Fire or other_particle.material == Lava
        ) and random.random() < 0.2:  # 20% chance to ignite
            particle.to_remove = True
            return [
                Fire.create_particle(
                    space, particle.body.position.x, particle.body.position.y
                )
            ]
        elif other_particle.material == Acid:
            particle.to_remove = True
            return []
        return []


class Glass(Paint):
    COLOR = (10, 20, 15)
    MASS = 100
    SIZE = 10
    COLLISION_TYPE = 5
    FRICTION = 1.0
    ELASTICITY = 0.1
    SPREAD = 0
    VELOCITY_SPREAD = 0

    @classmethod
    def create_particle(cls, space, x, y, color=None):
        return super().create_particle(space, x, y)

    @classmethod
    def create_particles(cls, space, x, y, count=1, color=None):
        return super().create_particles(space, x, y, count, color)

    @classmethod
    def update_particle(cls, particle, dt, gravity):
        return super().update_particle(particle, dt, gravity)

    @classmethod
    def handle_collision(
        cls, space: Space, particle: Particle, other_particle: Particle
    ) -> List[Particle]:
        if (
            other_particle.material == Lava and random.random() < 0.1
        ):  # 10% chance to turn into lava
            particle.to_remove = True
            return [
                Lava.create_particle(
                    space, particle.body.position.x, particle.body.position.y
                )
            ]
        return []


class Acid(Fluid):
    COLOR = (0, 255, 0)
    MASS = 1.0
    SIZE = 4
    COLLISION_TYPE = 4
    FRICTION = 0.0
    ELASTICITY = 0.98

    @classmethod
    def create_particle(cls, space, x, y):
        return super().create_particle(space, x, y)

    @classmethod
    def update_particle(cls, particle, dt, gravity):
        return True

    @classmethod
    def handle_collision(
        cls, space: Space, particle: Particle, other_particle: Particle
    ) -> List[Particle]:
        if (
            other_particle.material == Water
            or other_particle.material == Fire
            or other_particle.material == Lava
        ):
            particle.to_remove = True
            return [
                Steam.create_particle(
                    space, particle.body.position.x, particle.body.position.y
                )
            ]
        return []

# ./particle.py
import pygame
import pymunk
import time
import math


class Particle:
    def __init__(
        self,
        space,
        x,
        y,
        mass,
        size,
        color,
        elasticity=0.5,
        friction=0.5,
        collision_type=0,
        lifetime=None,
        material=None,
    ):
        self.size = size  # Change radius to size
        self.body = pymunk.Body(
            mass=mass, moment=pymunk.moment_for_box(mass, (size, size))
        )
        self.body.position = x, y
        self.shape = pymunk.Poly.create_box(self.body, (size, size))
        self.shape.elasticity = elasticity
        self.shape.friction = friction
        self.shape.collision_type = collision_type
        self.color = color
        self.creation_time = time.time()
        self.lifetime = lifetime
        self.body.particle = self
        self.material = material
        self.to_remove = False
        space.add(self.body, self.shape)

    def draw(self, window):
        position = self.body.position
        angle = -self.body.angle  # Pymunk uses opposite rotation direction to Pygame

        # Create a surface for the particle
        surface = pygame.Surface((int(self.size), int(self.size)), pygame.SRCALPHA)
        
        # Draw the particle on the surface
        if isinstance(self.color, tuple) and len(self.color) == 4:
            pygame.draw.rect(surface, self.color, (0, 0, int(self.size), int(self.size)))
        else:
            pygame.draw.rect(surface, self.color, (0, 0, int(self.size), int(self.size)))

        # Rotate the surface
        rotated_surface = pygame.transform.rotate(surface, math.degrees(angle))
        
        # Get the new rect and calculate the position to blit
        rot_rect = rotated_surface.get_rect()
        blit_pos = (int(position.x - rot_rect.width / 2), int(position.y - rot_rect.height / 2))

        # Draw the rotated surface
        window.blit(rotated_surface, blit_pos)

# ./main.py
import pygame
from simulation import Simulation


def main():
    pygame.init()
    width, height = 600, 600
    window = pygame.display.set_mode((width, height))
    
    # Set the background color to black
    window.fill((0, 0, 0))
    pygame.display.flip()

    simulation = Simulation(window, width, height)
    simulation.run()

    pygame.quit()


if __name__ == "__main__":
    main()

